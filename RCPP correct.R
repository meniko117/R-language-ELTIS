cppFunction('NumericMatrix stockTurnover(NumericMatrix x, NumericMatrix y, NumericMatrix z, NumericMatrix p, int t) {
            int nrow = x.nrow(), ncol = x.ncol();
            
            NumericMatrix out(nrow*3, ncol);
            
            
            
            for (int i = 0; i < nrow; i++) {         // проход по рядам
            
            for (int j = t+2; j < 50; j++) {           // "j=t" проход по колонкам в ряду (начинаем с недели, следующей за текущей)
            out (i,t+1)=x (i,t+1);                            // создали начальные остатки по рядам
            
            out (i+2*nrow, j) = z(i,j);             // включаем блок с товарами в пути (нижняя треть таблицы)
            
            out (i,j) = out(i, j-1)-y(i,j)+z(i,j)+out(i+nrow,j-p(i,2)); // результирующее значение по остаткам на начало недели
            //вычитаем расход за предыдущую неделю и добавляем сгенерированный заказ на lead time недель ранее
            // также добавляем товары в пути, которые поступают на текущей неделе
            //p(i,2) 5-я колонка в таблице параметров срок доставки
            
            
            if (out(i,j) < p(i,0)*y(i,j) && j> t) {       //триггер "заказ"-"нет заказа"; p(i,3)  4-я колонка страховой запас в неделях (нумерация колонок с нуля)
            out (i+nrow,j)= p(i,1)*y(i,j);                //генерирование величины заказа в зависимости от плана продаж; p(i,4) 5-я колонка размер заказа
            }
            else {
            out (i+nrow,j) =0;                // значение "0", если остаток не меньше "страхового" запаса
            
            }
            }                                       // конец обхода колонок
            
            }                                       // конец обхода рядов
            
            
            
            for (int i = 0; i < nrow; i++) {         // проход по рядам НОВЫй ЦИКЛ
            
            for (int j = t+2; j < 50; j++) {           // проход по колонкам в ряду для смещения сгенерированного заказа (t+1) !!
            //на более ранний срок равный "сроку доставки"
            
            out (i+nrow,j) = out(i+nrow, j+(p(i,2)-1)); //  "p(i,2)" уменьшить еще на ЕДИНИЦУ?
            out (i,j+1) = out(i, j-1)-y(i,j)+z(i,j)+out(i+nrow,j-p(i,2));  // добавить в левой части уравнения  out (...j+1), чтобы сохранить превоначальные остатки
            
            }
            
            }
            
            for (int r = t+2; r < ncol; r++) {         // ДОБАВЛЕННЫЙ ЦИКЛ проход по КОЛИЧЕСТВУ КОЛОНОК !!
            
            for (int i = 0; i < nrow; i++) {
            
            for (int j = t+2; j < 50; j++) {          // !!
            
            if (out(i,j+p(i,2)-1) < p(i,0)*y(i,j) && j> t+1 ) {                       //обнуление "лишних заказов"
            out (i+nrow,j)= p(i,1)*y(i,j+p(i,2));  // в правой части стояло p(i,1)*y(i,j);
            }
            else {
            out (i+nrow,j) =0;
            
            }
            //            out (i+nrow,j) = out(i+nrow, j+(p(i,2)-1)); // !!!! добавлена строка
            
            out (i,j) = out(i, j-1)-y(i,j)+z(i,j)+out(i+nrow,j-p(i,2));
            
            }                                       // конец обхода колонок
            
            
            }                                       // конец обхода рядов
            
            
            } //ДОБАВЛЕННЫЙ ЦИКЛ
            
            
            return out;                             // возврат вектора значений по всем рядам
            
            }')
